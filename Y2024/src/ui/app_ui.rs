use std::time::{Duration, Instant};

use color_eyre::Result;
use ratatui::DefaultTerminal;
use ratatui::crossterm::event::{self, Event, KeyCode, KeyEvent, KeyEventKind};
use ratatui::widgets::{ListState, Paragraph, Widget};
use ratatui::layout::{Rect, Layout, Constraint};
use ratatui::buffer::Buffer;
use ratatui::style::Stylize;

use crate::tasks::t0;

use crate::tasks::TaskRunner;

use super::data_entry::DataEntry;
use super::days::DayUI;
use super::SubUiResponse;

pub struct AppUI {
  should_exit: bool,
  current_page: UIStatus,
  task_runner: Option<Box<dyn TaskRunner>>,
  ui_day_list: DayUI<'static>,
  ui_data_entry: DataEntry,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
enum UIStatus {
  Main,
  DataEntry,
}

const TICK_RATE: Duration = Duration::from_millis(250);

impl Default for AppUI {
  fn default() -> Self {
      let mut day_state = ListState::default();
      day_state.select_first();

      Self {
        should_exit: false,
        current_page: UIStatus::Main,
        task_runner: None,
        ui_day_list: DayUI::default(),
        ui_data_entry: DataEntry::default(),
      }
  }
}

impl AppUI {
  pub fn run(mut self, mut terminal: DefaultTerminal) -> Result<()> {
    let mut last_tick = Instant::now();

    while !self.should_exit {
      terminal.draw(|frame| frame.render_widget( &mut self, frame.area()))?;

      let timeout = TICK_RATE.saturating_sub(last_tick.elapsed());
      if event::poll(timeout)? {
        if let Event::Key(key) = event::read()? {
          let response = match self.current_page {
            UIStatus::Main => self.ui_day_list.send_event(key),
            UIStatus::DataEntry => self.ui_data_entry.send_event(key),
            // _ => SubUiResponse::None,
          };
  
          self.handle_response(response);
        }
      }

      if last_tick.elapsed() >= TICK_RATE {
        last_tick = Instant::now();
      }
    }
    Ok(())
  }

  #[allow(dead_code)]
  fn fallback_send_event(&mut self, key: KeyEvent) -> SubUiResponse {
    if key.kind != KeyEventKind::Press {
      return SubUiResponse::None;
    }
    return match key.code {
      KeyCode::Char('q') | KeyCode::Esc => SubUiResponse::Exit,
      _ => SubUiResponse::None
    }
  }

  fn handle_response(&mut self, response: SubUiResponse) {
    match response {
      SubUiResponse::Exit => {
        match self.current_page {
          UIStatus::DataEntry => self.current_page = UIStatus::Main,
          UIStatus::Main => self.should_exit = true,
        }
      },
      SubUiResponse::SelectDay(day) => self.select_day(day),
      SubUiResponse::AcceptInput(data) => {
        self.task_runner.as_mut().unwrap().input(data);
        self.current_page = UIStatus::Main;
      },
      _ => {}
    }
  }

  fn select_day(&mut self, day: usize) {
    match day {
      0 => {
        self.task_runner = Some(Box::new(t0::T0::new()));
        self.current_page = UIStatus::DataEntry;
      },
      _ => {
        self.task_runner = None;
        self.current_page = UIStatus::Main;
      },
    }
  }
}

impl Widget for &mut AppUI {
  fn render(self, area: Rect, buf: &mut Buffer)
    where
      Self: Sized {
    let [header, main, footer] = Layout::vertical([
      Constraint::Length(2),
      Constraint::Fill(1),
      Constraint::Length(1),
    ]).areas(area);

    AppUI::render_header(self.current_page, header, buf);
    AppUI::render_footer(self.current_page, footer, buf);
    self.render_main_app(main, buf);
  }
}

impl AppUI {
  fn render_header(state: UIStatus, area: Rect, buf: &mut Buffer) {
    let [l1] = Layout::vertical([Constraint::Length(1)]).areas(area);
    let header_text = match state {
      UIStatus::Main => "Advent of Code - Year 2024 (Ratatui Edition)",
      UIStatus::DataEntry => "Please Enter or Paste the random data generated by AoC",
    };
    Paragraph::new(header_text)
      .bold()
      .centered()
      .render(l1, buf);
  }

  fn render_footer(page: UIStatus, area: Rect, buf: &mut Buffer) {
    let footer_text = match page {
      UIStatus::Main => "Select a Day, use Arrow Keys UP and DOWN or <j> and <k> (vim) to move in Day-List, <Enter> to select",
      UIStatus::DataEntry => "Copy your input and paste it with <p>, exit to main menu with <q>, scroll with arrow keys"
    };

    Paragraph::new(footer_text)
      .bold()
      .render(area, buf);
  }

  fn render_main_app(&mut self, area: Rect, buf: &mut Buffer) {
    match self.current_page {
      UIStatus::Main => self.ui_day_list.render(area, buf),
      UIStatus::DataEntry => self.ui_data_entry.render(area, buf),
      #[allow(unreachable_patterns)]
      _ => AppUI::not_implemented(self.current_page, area, buf)
    }
  }

  fn not_implemented(state: UIStatus, area: Rect, buf: &mut Buffer) {
    Paragraph::new(format!("The Day {:?} has not been implemented yet!", state))
      .bold()
      .centered()
      .render(area, buf);
  }
}