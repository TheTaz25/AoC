use std::time::{Duration, Instant};

use color_eyre::Result;
use ratatui::DefaultTerminal;
use ratatui::crossterm::event::{self, Event, KeyCode, KeyEvent, KeyEventKind};
use ratatui::widgets::{ListState, Paragraph, Widget};
use ratatui::layout::{Rect, Layout, Constraint};
use ratatui::buffer::Buffer;
use ratatui::style::Stylize;

use super::data_entry::DataEntry;
use super::days::DayUI;
use super::result::UiResult;
use super::runner::RunnerUi;
use super::SubUiResponse;

pub struct AppUI {
  should_exit: bool,
  current_page: UIStatus,
  ui_runner: RunnerUi,
  ui_day_list: DayUI<'static>,
  ui_data_entry: DataEntry,
  ui_result: UiResult
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
enum UIStatus {
  Main,
  DataEntry,
  Result,
}

const TICK_RATE: Duration = Duration::from_millis(250);

impl Default for AppUI {
  fn default() -> Self {
      let mut day_state = ListState::default();
      day_state.select_first();

      Self {
        should_exit: false,
        current_page: UIStatus::Main,
        ui_day_list: DayUI::default(),
        ui_data_entry: DataEntry::default(),
        ui_result: UiResult::default(),
        ui_runner: RunnerUi::default(),
      }
  }
}

impl AppUI {
  pub async fn run(mut self, mut terminal: DefaultTerminal) -> Result<()> {
    let mut last_tick = Instant::now();

    while !self.should_exit {
      terminal.draw(|frame| frame.render_widget( &mut self, frame.area()))?;

      let timeout = TICK_RATE.saturating_sub(last_tick.elapsed());
      if event::poll(timeout)? {
        if let Event::Key(key) = event::read()? {
          let response = match self.current_page {
            UIStatus::Main => self.ui_day_list.send_event(key),
            UIStatus::DataEntry => self.ui_data_entry.send_event(key),
            UIStatus::Result => self.ui_result.send_event(key),
            #[allow(unreachable_patterns)]
            _ => SubUiResponse::None,
          };
  
          self.handle_response(response).await;
        }
      }

      if last_tick.elapsed() >= TICK_RATE {
        last_tick = Instant::now();
      }
    }
    Ok(())
  }

  #[allow(dead_code)]
  fn fallback_send_event(&mut self, key: KeyEvent) -> SubUiResponse {
    if key.kind != KeyEventKind::Press {
      return SubUiResponse::None;
    }
    return match key.code {
      KeyCode::Char('q') | KeyCode::Esc => SubUiResponse::Exit,
      _ => SubUiResponse::None
    }
  }

  async fn handle_response(&mut self, response: SubUiResponse) {
    match response {
      // Handle various Exit Commands
      SubUiResponse::Exit => {
        match self.current_page {
          UIStatus::DataEntry => self.current_page = UIStatus::Main,
          UIStatus::Main => self.should_exit = true,
          UIStatus::Result => self.current_page = UIStatus::Main,
        }
      },
      // When user hits enter on a day
      SubUiResponse::SelectDay(day) => {
        self.ui_runner.set_selected_day(day);
        self.current_page = UIStatus::DataEntry;
      },
      // User entered input
      SubUiResponse::AcceptInput(data) => {
        self.ui_runner.set_data(data);
        self.current_page = UIStatus::Main;
      },
      // User hit enter
      SubUiResponse::RunTask => {
        if self.ui_runner.is_ready() {
          self.ui_runner.execute();
          self.current_page = UIStatus::Result;
          self.ui_result.set_result(self.ui_runner.result_data.clone());
        }
      },
      _ => {}
    }
  }

}

impl Widget for &mut AppUI {
  fn render(self, area: Rect, buf: &mut Buffer)
    where
      Self: Sized {
    let [header, main, footer] = Layout::vertical([
      Constraint::Length(2),
      Constraint::Fill(1),
      Constraint::Length(1),
    ]).areas(area);

    AppUI::render_header(self.current_page, header, buf);
    AppUI::render_footer(self.current_page, footer, buf);
    self.render_main_app(main, buf);
  }
}

impl AppUI {
  fn render_header(state: UIStatus, area: Rect, buf: &mut Buffer) {
    let [l1] = Layout::vertical([Constraint::Length(1)]).areas(area);
    let header_text = match state {
      UIStatus::Main => "Advent of Code - Year 2024 (Ratatui Edition)",
      UIStatus::DataEntry => "Please Enter or Paste the random data generated by AoC",
      UIStatus::Result => "Results",
    };
    Paragraph::new(header_text)
      .bold()
      .centered()
      .render(l1, buf);
  }

  fn render_footer(page: UIStatus, area: Rect, buf: &mut Buffer) {
    let footer_text = match page {
      UIStatus::Main => "Select a Day, use Arrow Keys UP and DOWN or <j> and <k> (vim) to move in Day-List, <Enter> to select, <r> to run selected day",
      UIStatus::DataEntry => "Copy your input and paste it with <p>, exit to main menu with <q>, scroll with arrow keys",
      UIStatus::Result => "",
    };

    Paragraph::new(footer_text)
      .bold()
      .render(area, buf);
  }

  fn render_main_app(&mut self, area: Rect, buf: &mut Buffer) {
    match self.current_page {
      UIStatus::Main => self.ui_day_list.render(area, buf),
      UIStatus::DataEntry => self.ui_data_entry.render(area, buf),
      UIStatus::Result => self.ui_result.render(area, buf),
      #[allow(unreachable_patterns)]
      _ => AppUI::not_implemented(self.current_page, area, buf)
    }
  }

  fn not_implemented(state: UIStatus, area: Rect, buf: &mut Buffer) {
    Paragraph::new(format!("The Day {:?} has not been implemented yet!", state))
      .bold()
      .centered()
      .render(area, buf);
  }
}